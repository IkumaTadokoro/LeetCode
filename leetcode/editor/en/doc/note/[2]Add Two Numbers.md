## メモ

- ListNodeクラスが二つ与えられる
- 戻り値もListNode
- ListNodeはlinked-listなので、現在値と次の値に対するポインタを持つ
- 数字は逆順で格納されている
    - [2, 4, 3]なら342である。

## 方針検討

- やること
    - ListNodeから数字を組み立てる
    - 合計する
    - 合計した数値をListNodeに分解する
- 数字を組み立てる
    - [2, 4, 3]
    - 2 * 10^0 + 4 * 10^1 + 3 * 10^2
- 合計するのは単純に加算するだけ
- 合計した数値を分解する
    - 807を[7, 0, 8]にする
    - 807 / 10 = 80 ... 7
    - 80 / 10 = 8 ... 0
    - 8 / 10 = 0 ... 8
    - 商が10より小さくなるまで再帰的に処理を行う。
- ListNodeクラスのインスタンスを作成する必要がある。
  - 最初のループで、とりあえずvalだけの値でnewする。
  - ListNode.new(val, next)のnextがメソッド呼び出しになるのか
  - ガード節は、nextが存在しない条件になった時。つまり与えられた数値が10より小さい時、nextがないListNodeを返す

## 1回目提出後

- 1の位から計算する
- 繰り上がりが発生する可能性があるが、繰り上がりの桁は最大1（max：9 + 9 = 18）である。
- 疑似コードで書くと次のような処理になる

- current nodeとdummy head（戻り値用）を初期化する
- carry（繰り上がり判定）を0で初期化する
- l1とl2を変数pとqにそれぞれ代入する
- l1とl2のそれぞれのリストの終端に至るまでループする
    - xにpの値を格納する。pがl1の終端であれば、0をセットする 
    - yにqの値を格納する。qがl2の終端であれば、0をセットする
    - 合計に x + y + carry をセットする
    - carryを sum / 10 で更新する
    - sum % 10で新しいノードを作り、current nodeの`_next`に設定する。current_nodeを次に進める
    - pとqを次に進める
- carry = 1であれば、戻り値の次の値に1をセットする
- dummy headの次のnodeをreturnする

- dummy headを利用することで、コードをシンプルにすることができる。具体的には以下のケースをベット考える必要がなくなる。
    - リストの長さが異なる場合
    - 片方のリストが空の場合
    - 繰り上がりが最後に発生する場合、

- 計算量はO(max(l1.length, l2.length))
